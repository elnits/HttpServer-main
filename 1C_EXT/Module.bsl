#Область СлужебныеПеременные

Перем АдресСервера;

Перем ИдентификаторВыгрузки;

// Добавляем новые переменные для пакетной выгрузки
Перем ИспользоватьПакетнуюВыгрузку;
Перем РазмерПакета;

// Переменная для хранения идентификатора базы данных
Перем ИдентификаторБазыДанных;

// Переменные для отслеживания прогресса выгрузки (на клиенте)
Перем ОбщееКоличествоОбъектов;
Перем ТекущаяПозиция;
Перем ВыполняетсяВыгрузка;
Перем ТребуетсяПрервать;
Перем ТекущийЭтап;
Перем ТекущийОбъект;

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Вспомогательная функция для экранирования специальных символов в XML
Функция ЭкранироватьXML(Строка)
	
	Результат = Строка;
	Результат = СтрЗаменить(Результат, "&", "&amp;");
	Результат = СтрЗаменить(Результат, "<", "&lt;");
	Результат = СтрЗаменить(Результат, ">", "&gt;");
	Результат = СтрЗаменить(Результат, """", "&quot;");
	Результат = СтрЗаменить(Результат, "'", "&apos;");
	
	Возврат Результат;
	
КонецФункции

// Получение версии 1С
Функция Версия1С()
	
	Попытка
		// Используем СистемнаяИнформация для получения версии платформы
		СистемнаяИнформация = Новый СистемнаяИнформация;
		Возврат Строка(СистемнаяИнформация.ВерсияПриложения);
	Исключение
		// Если не удалось получить версию, возвращаем базовую
		Возврат "8.3";
	КонецПопытки;
	
КонецФункции

// Получение имени конфигурации
Функция ИмяКонфигурации()
	
	Попытка
		// Правильный способ получения имени конфигурации
		Возврат Строка(Метаданные.Имя);
	Исключение
		// Если не удалось получить имя, возвращаем пустую строку
		Возврат "";
	КонецПопытки;
	
КонецФункции

// Получение подстроки из середины строки
Функция Средняя(Строка, НачальнаяПозиция, Длина)
	
	Возврат Сред(Строка, НачальнаяПозиция, Длина);
	
КонецФункции

// Получение версии конфигурации
Функция ПолучитьВерсиюКонфигурации()
	
	Попытка
		Возврат Строка(Метаданные.Версия);
	Исключение
		Возврат "";
	КонецПопытки;
	
КонецФункции

// Извлечение значения из XML по тегу
Функция ИзвлечьЗначениеИзXML(XMLСтрока, ИмяТега)
	
	ПозицияНачала = СтрНайти(XMLСтрока, "<" + ИмяТега + ">");
	ПозицияКонца = СтрНайти(XMLСтрока, "</" + ИмяТега + ">");
	
	Если ПозицияНачала > 0 И ПозицияКонца > 0 Тогда
		Возврат Средняя(XMLСтрока, ПозицияНачала + СтрДлина("<" + ИмяТега + ">"), ПозицияКонца - ПозицияНачала - СтрДлина("<" + ИмяТега + ">"));
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Получение тела ответа HTTP (универсальное)
Функция ПолучитьТелоОтвета(Ответ)
	
	Попытка
		Возврат Ответ.ПолучитьТелоКакСтроку();
	Исключение
		Попытка
			Возврат Ответ.ТелоОтвета;
		Исключение
			Возврат "Не удалось получить тело ответа";
		КонецПопытки;
	КонецПопытки;
	
КонецФункции

// Безопасное получение кода состояния из HTTP ответа
Функция ПолучитьКодСостояния(Ответ)
	
	КодСостояния = 0;
	Попытка
		КодСостояния = Число(Ответ.КодСостояния);
	Исключение
		Попытка
			КодСостояния = Ответ.КодСостояния;
		Исключение
			КодСостояния = 0;
		КонецПопытки;
	КонецПопытки;
	
	Возврат КодСостояния;
	
КонецФункции

// Получение XML представления значения константы
Функция ПолучитьXMLПредставлениеЗначения(Значение, ТипЗначения)
	
	Если Значение = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ТипЗначенияОбъекта = ТипЗнч(Значение);
	СтрокаТипа = Строка(ТипЗначенияОбъекта);
	
	// Для ссылок используем полное представление в XML формате
	Если СтрНайти(СтрокаТипа, "Ссылка") > 0 Тогда
		СтрокаЗначения = Формат(Значение, "ДЛФ=DT");
		Возврат "<reference>" + ЭкранироватьXML(СтрокаЗначения) + "</reference>";
	КонецЕсли;
	
	// Для таблиц значений - сериализация в XML
	Если ТипЗначенияОбъекта = Тип("ТаблицаЗначений") Тогда
		Возврат СериализоватьТаблицуЗначенийВXML(Значение);
	КонецЕсли;
	
	// Для структур - сериализация в XML
	Если ТипЗначенияОбъекта = Тип("Структура") Тогда
		Возврат СериализоватьСтруктуруВXML(Значение);
	КонецЕсли;
	
	// Для массивов - сериализация в XML
	Если ТипЗначенияОбъекта = Тип("Массив") Тогда
		Возврат СериализоватьМассивВXML(Значение);
	КонецЕсли;
	
	// Для дат используем правильный формат в XML
	Если ТипЗначенияОбъекта = Тип("Дата") Тогда
		СтрокаЗначения = Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss");
		Возврат "<date>" + ЭкранироватьXML(СтрокаЗначения) + "</date>";
	КонецЕсли;
	
	// Для чисел - в XML теге
	Если ТипЗначенияОбъекта = Тип("Число") Тогда
		СтрокаЗначения = Строка(Значение);
		Возврат "<number>" + ЭкранироватьXML(СтрокаЗначения) + "</number>";
	КонецЕсли;
	
	// Для булевых - в XML теге
	Если ТипЗначенияОбъекта = Тип("Булево") Тогда
		СтрокаЗначения = Строка(Значение);
		Возврат "<boolean>" + ЭкранироватьXML(СтрокаЗначения) + "</boolean>";
	КонецЕсли;
	
	// Для строк - в XML теге
	Если ТипЗначенияОбъекта = Тип("Строка") Тогда
		Возврат "<string>" + ЭкранироватьXML(Значение) + "</string>";
	КонецЕсли;
	
	// Для остальных типов - стандартное преобразование в XML теге
	СтрокаЗначения = Строка(Значение);
	Возврат "<value>" + ЭкранироватьXML(СтрокаЗначения) + "</value>";
	
КонецФункции

// Сериализация таблицы значений в XML
Функция СериализоватьТаблицуЗначенийВXML(ТаблицаЗначений)
	
	XMLСтрока = "<table>";
	
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		
		XMLСтрока = XMLСтрока + "<row>";
		
		Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			
			ЗначениеКолонки = СтрокаТаблицы[Колонка.Имя];
			СтрокаЗначения = "";
			
			Если ЗначениеКолонки <> Неопределено Тогда
				СтрокаЗначения = Строка(ЗначениеКолонки);
				СтрокаЗначения = ЭкранироватьXML(СтрокаЗначения);
			КонецЕсли;
			
			XMLСтрока = XMLСтрока + "<" + Колонка.Имя + ">" + СтрокаЗначения + "</" + Колонка.Имя + ">";
			
		КонецЦикла;
		
		XMLСтрока = XMLСтрока + "</row>";
		
	КонецЦикла;
	
	XMLСтрока = XMLСтрока + "</table>";
	
	Возврат XMLСтрока;
	
КонецФункции

// Сериализация структуры в XML
Функция СериализоватьСтруктуруВXML(Структура)
	
	XMLСтрока = "<structure>";
	
	Для Каждого КлючЗначение Из Структура Цикл
		
		Значение = КлючЗначение.Значение;
		СтрокаЗначения = "";
		
		Если Значение <> Неопределено Тогда
			СтрокаЗначения = Строка(Значение);
			СтрокаЗначения = ЭкранироватьXML(СтрокаЗначения);
		КонецЕсли;
		
		XMLСтрока = XMLСтрока + "<" + КлючЗначение.Ключ + ">" + СтрокаЗначения + "</" + КлючЗначение.Ключ + ">";
		
	КонецЦикла;
	
	XMLСтрока = XMLСтрока + "</structure>";
	
	Возврат XMLСтрока;
	
КонецФункции

// Сериализация массива в XML
Функция СериализоватьМассивВXML(Массив)
	
	XMLСтрока = "<array>";
	
	Для Индекс = 0 По Массив.ВГраница() Цикл
		
		Значение = Массив[Индекс];
		СтрокаЗначения = "";
		
		Если Значение <> Неопределено Тогда
			СтрокаЗначения = Строка(Значение);
			СтрокаЗначения = ЭкранироватьXML(СтрокаЗначения);
		КонецЕсли;
		
		XMLСтрока = XMLСтрока + "<item>" + СтрокаЗначения + "</item>";
		
	КонецЦикла;
	
	XMLСтрока = XMLСтрока + "</array>";
	
	Возврат XMLСтрока;
	
КонецФункции

#КонецОбласти

#Область ФункцииИдентификацииБазыДанных

// Определение database_id с приоритетами (без использования глобальных переменных)
&НаСервере
Функция ОпределитьDatabaseID(АдресСервераПараметр, ИдентификаторБазыДанныхПараметр, ClientIDПараметр, ProjectIDПараметр) Экспорт
    
    // Приоритет 1: прямой database_id
    Если Не ПустаяСтрока(ИдентификаторБазыДанныхПараметр) Тогда
        // Проверяем существование
        Если ПроверитьСуществованиеDatabaseID(АдресСервераПараметр, ИдентификаторБазыДанныхПараметр) Тогда
            Возврат ИдентификаторБазыДанныхПараметр;
        КонецЕсли;
    КонецЕсли;
    
    // Приоритет 2: поиск по client_id и project_id (если указаны)
    Если Не ПустаяСтрока(ClientIDПараметр) И Не ПустаяСтрока(ProjectIDПараметр) Тогда
        DatabaseID = НайтиDatabaseПоКлиентуИПроекту(АдресСервераПараметр, ClientIDПараметр, ProjectIDПараметр);
        Если Не ПустаяСтрока(DatabaseID) Тогда
            Возврат DatabaseID;
        КонецЕсли;
        
        // Если не найдено, создаем новую
        DatabaseID = СоздатьDatabaseПоКлиентуИПроекту(АдресСервераПараметр, ClientIDПараметр, ProjectIDПараметр);
        Если Не ПустаяСтрока(DatabaseID) Тогда
            Возврат DatabaseID;
        КонецЕсли;
    КонецЕсли;
    
    // Если ничего не найдено
    ВызватьИсключение "Не указан database_id или client_id/project_id";
    
КонецФункции

// Поиск database_id по client_id и project_id (без использования глобальных переменных)
&НаСервере
Функция НайтиDatabaseПоКлиентуИПроекту(АдресСервераПараметр, ClientID, ProjectID)
    
    URL = АдресСервераПараметр + "/api/databases/find?client_id=" + ClientID + "&project_id=" + ProjectID;
    
    Попытка
        // Парсим URL для получения базового адреса и пути
        ПозицияПротокола = СтрНайти(URL, "://");
        Если ПозицияПротокола > 0 Тогда
            URLБезПротокола = Прав(URL, СтрДлина(URL) - ПозицияПротокола - 2);
            ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
            Если ПозицияСлеша > 0 Тогда
                БазовыйАдресСервера = Лев(URLБезПротокола, ПозицияСлеша - 1);
                ПутьЗапроса = Прав(URLБезПротокола, СтрДлина(URLБезПротокола) - ПозицияСлеша + 1);
            Иначе
                БазовыйАдресСервера = URLБезПротокола;
                ПутьЗапроса = "/";
            КонецЕсли;
        Иначе
            БазовыйАдресСервера = URL;
            ПутьЗапроса = "/";
        КонецЕсли;
        
        Заголовки = Новый Соответствие;
        Заголовки.Вставить("Accept", "application/json");
        
        HTTPЗапрос = Новый HTTPЗапрос(ПутьЗапроса, Заголовки);
        HTTPСоединение = Новый HTTPСоединение(БазовыйАдресСервера, , , , , 30);
        Ответ = HTTPСоединение.Получить(HTTPЗапрос);
        
        КодСостояния = ПолучитьКодСостояния(Ответ);
        
        Если КодСостояния = 200 Тогда
            Тело = ПолучитьТелоОтвета(Ответ);
            // Парсим JSON ответ
            DatabaseID = ИзвлечьЗначениеИзJSON(Тело, "database_id");
            Возврат DatabaseID;
        ИначеЕсли КодСостояния = 404 Тогда
            // База не найдена
            Возврат "";
        Иначе
            ВызватьИсключение "Ошибка при поиске базы данных: " + Строка(КодСостояния);
        КонецЕсли;
        
    Исключение
        Сообщить("Ошибка при поиске database_id: " + ОписаниеОшибки());
        Возврат "";
    КонецПопытки;
    
КонецФункции

// Создание новой базы данных (без использования глобальных переменных)
&НаСервере
Функция СоздатьDatabaseПоКлиентуИПроекту(АдресСервераПараметр, ClientID, ProjectID)
    
    URL = АдресСервераПараметр + "/api/clients/" + ClientID + "/projects/" + ProjectID + "/databases";
    
    ИмяБазы = "База из 1С от " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy HH:mm:ss");
    
    JSONТело = "{""name"": """ + ЭкранироватьJSON(ИмяБазы) + """, ""file_path"": """", ""description"": ""Автоматически создана из обработки 1С""}";
    
    Попытка
        // Парсим URL для получения базового адреса и пути
        ПозицияПротокола = СтрНайти(URL, "://");
        Если ПозицияПротокола > 0 Тогда
            URLБезПротокола = Прав(URL, СтрДлина(URL) - ПозицияПротокола - 2);
            ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
            Если ПозицияСлеша > 0 Тогда
                БазовыйАдресСервера = Лев(URLБезПротокола, ПозицияСлеша - 1);
                ПутьЗапроса = Прав(URLБезПротокола, СтрДлина(URLБезПротокола) - ПозицияСлеша + 1);
            Иначе
                БазовыйАдресСервера = URLБезПротокола;
                ПутьЗапроса = "/";
            КонецЕсли;
        Иначе
            БазовыйАдресСервера = URL;
            ПутьЗапроса = "/";
        КонецЕсли;
        
        Заголовки = Новый Соответствие;
        Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
        Заголовки.Вставить("Accept", "application/json");
        
        HTTPЗапрос = Новый HTTPЗапрос(ПутьЗапроса, Заголовки);
        HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело, КодировкаТекста.UTF8);
        HTTPСоединение = Новый HTTPСоединение(БазовыйАдресСервера, , , , , 30);
        Ответ = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
        
        КодСостояния = ПолучитьКодСостояния(Ответ);
        
        Если КодСостояния = 201 Или КодСостояния = 200 Тогда
            Тело = ПолучитьТелоОтвета(Ответ);
            DatabaseID = ИзвлечьЗначениеИзJSON(Тело, "id");
            Возврат Строка(DatabaseID);
        Иначе
            ВызватьИсключение "Ошибка при создании базы данных: " + Строка(КодСостояния);
        КонецЕсли;
        
    Исключение
        Сообщить("Ошибка при создании database: " + ОписаниеОшибки());
        Возврат "";
    КонецПопытки;
    
КонецФункции

// Проверка существования database_id (без использования глобальных переменных)
&НаСервере
Функция ПроверитьСуществованиеDatabaseID(АдресСервераПараметр, DatabaseID)
    
    URL = АдресСервераПараметр + "/api/v1/databases/" + DatabaseID;
    
    Попытка
        // Парсим URL для получения базового адреса и пути
        ПозицияПротокола = СтрНайти(URL, "://");
        Если ПозицияПротокола > 0 Тогда
            URLБезПротокола = Прав(URL, СтрДлина(URL) - ПозицияПротокола - 2);
            ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
            Если ПозицияСлеша > 0 Тогда
                БазовыйАдресСервера = Лев(URLБезПротокола, ПозицияСлеша - 1);
                ПутьЗапроса = Прав(URLБезПротокола, СтрДлина(URLБезПротокола) - ПозицияСлеша + 1);
            Иначе
                БазовыйАдресСервера = URLБезПротокола;
                ПутьЗапроса = "/";
            КонецЕсли;
        Иначе
            БазовыйАдресСервера = URL;
            ПутьЗапроса = "/";
        КонецЕсли;
        
        Заголовки = Новый Соответствие;
        Заголовки.Вставить("Accept", "application/json");
        
        HTTPЗапрос = Новый HTTPЗапрос(ПутьЗапроса, Заголовки);
        HTTPСоединение = Новый HTTPСоединение(БазовыйАдресСервера, , , , , 30);
        Ответ = HTTPСоединение.Получить(HTTPЗапрос);
        
        КодСостояния = ПолучитьКодСостояния(Ответ);
        Возврат КодСостояния = 200;
        
    Исключение
        Возврат Ложь;
    КонецПопытки;
    
КонецФункции

// Извлечение значения из JSON
&НаСервере
Функция ИзвлечьЗначениеИзJSON(JSONСтрока, ИмяПоля)
    
    // Простой парсинг JSON (можно улучшить)
    ПозицияНачала = СтрНайти(JSONСтрока, """" + ИмяПоля + """:");
    Если ПозицияНачала = 0 Тогда
        Возврат "";
    КонецЕсли;
    
    ПозицияНачала = ПозицияНачала + СтрДлина("""" + ИмяПоля + """:");
    // Пропускаем пробелы
    Пока ПозицияНачала <= СтрДлина(JSONСтрока) И Сред(JSONСтрока, ПозицияНачала, 1) = " " Цикл
        ПозицияНачала = ПозицияНачала + 1;
    КонецЦикла;
    
    Если ПозицияНачала > СтрДлина(JSONСтрока) Тогда
        Возврат "";
    КонецЕсли;
    
    // Извлекаем значение (может быть число или строка)
    Если Сред(JSONСтрока, ПозицияНачала, 1) = """" Тогда
        // Строка
        ПозицияНачала = ПозицияНачала + 1;
        ПозицияКонца = СтрНайти(JSONСтрока, """", , ПозицияНачала);
        Если ПозицияКонца > 0 Тогда
            Возврат Сред(JSONСтрока, ПозицияНачала, ПозицияКонца - ПозицияНачала);
        КонецЕсли;
    Иначе
        // Число
        ПозицияКонца = ПозицияНачала;
        Пока ПозицияКонца <= СтрДлина(JSONСтрока) И (Сред(JSONСтрока, ПозицияКонца, 1) >= "0" И Сред(JSONСтрока, ПозицияКонца, 1) <= "9") Цикл
            ПозицияКонца = ПозицияКонца + 1;
        КонецЦикла;
        Если ПозицияКонца > ПозицияНачала Тогда
            Возврат Сред(JSONСтрока, ПозицияНачала, ПозицияКонца - ПозицияНачала);
        КонецЕсли;
    КонецЕсли;
    
    Возврат "";
    
КонецФункции

// Экранирование JSON
&НаСервере
Функция ЭкранироватьJSON(Строка)
    
    Результат = Строка;
    Результат = СтрЗаменить(Результат, "\", "\\");
    Результат = СтрЗаменить(Результат, """", "\""");
    Результат = СтрЗаменить(Результат, Символы.ПС, "\n");
    Результат = СтрЗаменить(Результат, Символы.ВК, "\r");
    Результат = СтрЗаменить(Результат, Символы.Таб, "\t");
    
    Возврат Результат;
    
КонецФункции

#КонецОбласти


