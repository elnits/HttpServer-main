# Сценарий интеграции с Arliai для процесса нормализации

## Обзор

Данный документ описывает сценарий интеграции Arliai API в процесс нормализации данных номенклатуры. Arliai используется для улучшения качества нормализации и категоризации товаров с помощью искусственного интеллекта.

## Текущее состояние

### Существующая система нормализации

Текущий процесс нормализации (`normalization/normalizer.go`) использует:
- **Правила на основе ключевых слов** (`normalization/categorizer.go`) - определяет категорию по наличию ключевых слов
- **Регулярные выражения** (`normalization/name_normalizer.go`) - удаляет технические коды, размеры, числа

### Существующая интеграция с Arliai

В проекте уже реализован:
- **AIClient** (`nomenclature/ai_client.go`) - клиент для работы с Arliai API
- **NomenclatureProcessor** (`nomenclature/processor.go`) - процессор для обработки номенклатуры с использованием Arliai

## Сценарий интеграции

### Этап 1: Подготовка и настройка

#### 1.1. Получение API ключа
```bash
# Установка переменной окружения
export ARLIAI_API_KEY="your-api-key-here"

# Или в Windows PowerShell
$env:ARLIAI_API_KEY="your-api-key-here"
```

#### 1.2. Проверка конфигурации
- Убедиться, что файл `КПВЭД.txt` существует и содержит актуальный справочник
- Проверить доступность API Arliai: `https://api.arliai.com/v1/chat/completions`
- Настроить параметры модели (по умолчанию: `GLM-4.5-Air`)

### Этап 2: Модификация процесса нормализации

#### 2.1. Создание AI-усиленного нормализатора

**Новый компонент: `normalization/ai_normalizer.go`**

```go
package normalization

import (
    "httpserver/nomenclature"
    "sync"
)

// AINormalizer использует Arliai для улучшенной нормализации
type AINormalizer struct {
    aiClient     *nomenclature.AIClient
    categorizer  *Categorizer  // Fallback на правила
    nameNormalizer *NameNormalizer  // Fallback на правила
    systemPrompt string
    useAI        bool  // Флаг использования AI
}
```

#### 2.2. Гибридный подход

**Стратегия обработки:**

1. **Предварительная фильтрация** (быстрые правила)
   - Использовать простые правила для очевидных случаев
   - Пропускать через AI только сложные/неоднозначные случаи

2. **AI-обработка** (для сложных случаев)
   - Товары без четкой категории
   - Товары с опечатками или нестандартными названиями
   - Товары, требующие контекстного понимания

3. **Fallback на правила** (при ошибках API)
   - Если Arliai недоступен или возвращает ошибку
   - Использовать существующие правила как резерв

### Этап 3: Процесс нормализации с Arliai

#### 3.1. Последовательность операций

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Загрузка данных из catalog_items                         │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Предварительная обработка (быстрые правила)             │
│    - Простая нормализация имени (regex)                    │
│    - Определение очевидных категорий                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Определение необходимости AI-обработки                  │
│    - Категория = "другое" → требует AI                     │
│    - Низкая уверенность в категории → требует AI          │
│    - Сложное/нестандартное название → требует AI           │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Пакетная обработка через Arliai API                     │
│    - Группировка запросов для эффективности                │
│    - Параллельная обработка (2 потока)                     │
│    - Rate limiting (500ms между запросами)                 │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Обработка результатов                                    │
│    - Парсинг JSON ответов от Arliai                        │
│    - Валидация результатов                                  │
│    - Fallback на правила при ошибках                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. Группировка по (категория, normalized_name)            │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. Сохранение в normalized_data                            │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2. Системный промпт для нормализации

```go
systemPrompt := `Ты - эксперт по нормализации наименований товаров и их категоризации.

ТВОЯ ЗАДАЧА:
1. НОРМАЛИЗОВАТЬ наименование товара:
   - Исправить опечатки
   - Привести к стандартной форме
   - Удалить технические коды, размеры, числа (но сохранить смысл)
   - Унифицировать синонимы

2. ОПРЕДЕЛИТЬ КАТЕГОРИЮ товара из списка:
   - инструмент
   - медикаменты
   - стройматериалы
   - электроника
   - оборудование
   - расходники
   - автоаксессуары
   - канцелярия
   - средства очистки
   - продукты
   - сельское хозяйство
   - связь
   - сантехника
   - мебель
   - инструменты измерительные
   - программное обеспечение
   - упаковка
   - другое

ФОРМАТ ОТВЕТА - ТОЛЬКО JSON:
{
    "normalized_name": "нормализованное наименование",
    "category": "категория",
    "confidence": 0.95,
    "reasoning": "краткое объяснение выбора"
}

ВАЖНО:
- Отвечай ТОЛЬКО в указанном JSON формате
- Нормализованное имя должно быть понятным и стандартным
- Категория должна точно соответствовать товару`
```

### Этап 4: Реализация

#### 4.1. Модификация Normalizer

**Изменения в `normalization/normalizer.go`:**

```go
type Normalizer struct {
    db            *database.DB
    categorizer   *Categorizer
    nameNormalizer *NameNormalizer
    aiNormalizer  *AINormalizer  // Новый компонент
    events        chan<- string
    useAI         bool  // Флаг использования AI
}

func NewNormalizer(db *database.DB, events chan<- string, useAI bool) *Normalizer {
    normalizer := &Normalizer{
        db:            db,
        categorizer:   NewCategorizer(),
        nameNormalizer: NewNameNormalizer(),
        events:        events,
        useAI:         useAI,
    }
    
    if useAI {
        // Инициализация AI нормализатора
        apiKey := os.Getenv("ARLIAI_API_KEY")
        if apiKey != "" {
            normalizer.aiNormalizer = NewAINormalizer(apiKey)
        } else {
            log.Println("ARLIAI_API_KEY не установлен, AI нормализация отключена")
            normalizer.useAI = false
        }
    }
    
    return normalizer
}
```

#### 4.2. Логика обработки с AI

```go
func (n *Normalizer) processItem(item *database.CatalogItem) (category, normalizedName string) {
    // 1. Быстрая предварительная обработка
    category = n.categorizer.Categorize(item.Name)
    normalizedName = n.nameNormalizer.NormalizeName(item.Name)
    
    // 2. Определение необходимости AI-обработки
    needsAI := n.shouldUseAI(item.Name, category)
    
    if needsAI && n.useAI && n.aiNormalizer != nil {
        // 3. Обработка через Arliai
        aiResult, err := n.aiNormalizer.NormalizeWithAI(item.Name)
        if err == nil {
            // Используем результат от AI
            category = aiResult.Category
            normalizedName = aiResult.NormalizedName
            n.sendEvent(fmt.Sprintf("AI обработал: %s -> %s [%s]", 
                item.Name, normalizedName, category))
        } else {
            // Fallback на правила при ошибке
            n.sendEvent(fmt.Sprintf("AI ошибка для '%s', используем правила: %v", 
                item.Name, err))
        }
    }
    
    return category, normalizedName
}

func (n *Normalizer) shouldUseAI(name, category string) bool {
    // Используем AI если:
    // 1. Категория не определена (другое)
    if category == "другое" {
        return true
    }
    
    // 2. Название содержит нестандартные символы или выглядит сложным
    if len(name) > 50 || containsSpecialCases(name) {
        return true
    }
    
    // 3. Низкая уверенность в категории (можно добавить метрику)
    
    return false
}
```

### Этап 5: Оптимизация производительности

#### 5.1. Пакетная обработка

```go
// Группировка товаров для пакетной обработки
func (n *Normalizer) processBatchWithAI(items []*database.CatalogItem) {
    // Разбиваем на батчи по 10-20 товаров
    batchSize := 15
    for i := 0; i < len(items); i += batchSize {
        end := i + batchSize
        if end > len(items) {
            end = len(items)
        }
        
        batch := items[i:end]
        n.processAIBatch(batch)
    }
}
```

#### 5.2. Кэширование результатов

```go
// Кэш для часто встречающихся товаров
type AICache struct {
    cache map[string]*AIResult
    mutex sync.RWMutex
}

func (c *AICache) Get(name string) (*AIResult, bool) {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    result, exists := c.cache[strings.ToLower(name)]
    return result, exists
}
```

#### 5.3. Rate Limiting

```go
// Ограничение частоты запросов
rateLimiter := time.NewTicker(500 * time.Millisecond)
defer rateLimiter.Stop()

for _, item := range items {
    <-rateLimiter.C  // Ожидание перед запросом
    // Отправка запроса к API
}
```

### Этап 6: Обработка ошибок и отказоустойчивость

#### 6.1. Стратегия обработки ошибок

1. **Ошибка API (недоступность, таймаут)**
   - Fallback на правила
   - Логирование ошибки
   - Продолжение обработки остальных товаров

2. **Некорректный ответ от AI**
   - Валидация JSON
   - Fallback на правила
   - Повторная попытка (до 3 раз)

3. **Превышение лимитов API**
   - Ожидание и повтор
   - Увеличение задержки между запросами
   - Уведомление пользователя

#### 6.2. Логирование

```go
// Детальное логирование для отладки
log.Printf("[AI] Обработка: %s", item.Name)
log.Printf("[AI] Результат: category=%s, name=%s, confidence=%.2f", 
    result.Category, result.NormalizedName, result.Confidence)
log.Printf("[AI] Ошибка: %v", err)
```

### Этап 7: Мониторинг и метрики

#### 7.1. Сбор статистики

```go
type NormalizationStats struct {
    TotalItems        int
    ProcessedWithAI   int
    ProcessedWithRules int
    AIErrors          int
    AverageConfidence float64
    ProcessingTime    time.Duration
}
```

#### 7.2. Отчетность

- Количество товаров, обработанных через AI
- Количество товаров, обработанных правилами
- Процент успешных AI-обработок
- Средняя уверенность (confidence) от AI
- Время обработки

### Этап 8: Тестирование

#### 8.1. Тестовые сценарии

1. **Нормальная работа с AI**
   - API доступен
   - Корректные ответы
   - Проверка качества нормализации

2. **Работа без AI (fallback)**
   - API недоступен
   - Проверка работы правил

3. **Смешанный режим**
   - Часть товаров через AI, часть через правила
   - Проверка корректности группировки

4. **Обработка ошибок**
   - Таймауты
   - Некорректные ответы
   - Превышение лимитов

#### 8.2. Тестовые данные

```go
testCases := []struct {
    input    string
    expected struct {
        category string
        name     string
    }
}{
    {"Труба 100х100", struct{category, name string}{"стройматериалы", "труба"}},
    {"Энрофлоксацин 10%", struct{category, name string}{"медикаменты", "энрофлоксацин"}},
    // ...
}
```

### Этап 9: Развертывание

#### 9.1. Конфигурация

```go
// Конфигурация через переменные окружения
type NormalizationConfig struct {
    UseAI           bool
    ArliaiAPIKey    string
    AIModel         string
    MaxWorkers      int
    RateLimitDelay  time.Duration
    BatchSize       int
    CacheEnabled    bool
}
```

#### 9.2. API эндпоинт

```go
// POST /api/normalize/start?use_ai=true
func (s *Server) handleNormalizeStart(w http.ResponseWriter, r *http.Request) {
    useAI := r.URL.Query().Get("use_ai") == "true"
    
    normalizer := normalization.NewNormalizer(s.db, s.normalizerEvents, useAI)
    // ...
}
```

## Преимущества интеграции

1. **Улучшенная точность**
   - AI лучше понимает контекст
   - Исправление опечаток
   - Распознавание синонимов

2. **Гибкость**
   - Адаптация к новым типам товаров
   - Обучение на исторических данных
   - Меньше ручной настройки правил

3. **Масштабируемость**
   - Обработка больших объемов данных
   - Параллельная обработка
   - Кэширование результатов

4. **Отказоустойчивость**
   - Fallback на правила
   - Обработка ошибок
   - Продолжение работы при сбоях

## Ограничения и соображения

1. **Стоимость API**
   - Arliai API может иметь лимиты и стоимость
   - Необходимо мониторить использование

2. **Производительность**
   - AI-обработка медленнее правил
   - Необходима оптимизация (батчи, кэш)

3. **Зависимость от внешнего сервиса**
   - Требуется интернет-соединение
   - Возможны сбои API
   - Необходим fallback механизм

## Рекомендации

1. **Начните с гибридного подхода**
   - Используйте AI только для сложных случаев
   - Правила для очевидных товаров

2. **Мониторинг качества**
   - Сравнивайте результаты AI и правил
   - Собирайте метрики уверенности
   - Корректируйте промпты на основе результатов

3. **Постепенное внедрение**
   - Начните с небольшого процента товаров
   - Увеличивайте долю AI-обработки постепенно
   - Собирайте обратную связь

4. **Оптимизация затрат**
   - Кэширование частых запросов
   - Предварительная фильтрация
   - Батчинг запросов

## Заключение

Интеграция Arliai в процесс нормализации позволит значительно улучшить качество обработки данных, особенно для сложных и нестандартных случаев. Гибридный подход с fallback на правила обеспечит отказоустойчивость и производительность системы.

